<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>XLX的博客</title><link>https://XLXXLXXLX.github.io</link><description>紧急换电缆，循环追捕令</description><copyright>XLX的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://XLXXLXXLX.github.io</link></image><lastBuildDate>Mon, 09 Dec 2024 04:47:57 +0000</lastBuildDate><managingEditor>XLX的博客</managingEditor><ttl>60</ttl><webMaster>XLX的博客</webMaster><item><title>2024年第50周力扣打卡</title><link>https://XLXXLXXLX.github.io/post/2024-nian-di-50-zhou-li-kou-da-qia.html</link><description># 周一&#13;
签个到溜了&#13;
[1812. 判断国际象棋棋盘中一个格子的颜色](https://leetcode.cn/problems/determine-color-of-a-chessboard-square/)&#13;
```cpp&#13;
class Solution {&#13;
public:&#13;
    bool squareIsWhite(string coordinates) {&#13;
        return (coordinates[0] + coordinates[1]) % 2;&#13;
    }&#13;
};&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/2024-nian-di-50-zhou-li-kou-da-qia.html</guid><pubDate>Mon, 09 Dec 2024 04:46:59 +0000</pubDate></item><item><title>std::bitset，定长比特集</title><link>https://XLXXLXXLX.github.io/post/std--bitset%EF%BC%8C-ding-chang-bi-te-ji.html</link><description>[std::bitset - cppreference.com](https://zh.cppreference.com/w/cpp/utility/bitset)&#13;
与`std::vector&lt;bool&gt;`的关系类似于`std::array&lt;T, N&gt;`与`std::vector&lt;T&gt;`的关系，也就是同种元素的定长/非定长容器&#13;
&#13;
1. 可以由字符串或整形构造得到&#13;
2. operator[]访问特定位&#13;
3. 各种位操作的语法糖支持&#13;
4. to_string等转换函数&#13;
5. 大部分成员函数支持`constexpr`，提供很大便利。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/std--bitset%EF%BC%8C-ding-chang-bi-te-ji.html</guid><pubDate>Mon, 02 Dec 2024 05:33:02 +0000</pubDate></item><item><title>2024年第49周力扣打卡</title><link>https://XLXXLXXLX.github.io/post/2024-nian-di-49-zhou-li-kou-da-qia.html</link><description># 周一 &#13;
[n皇后II](https://leetcode.cn/problems/n-queens-ii/)&#13;
好久不写了，脑袋木掉了。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/2024-nian-di-49-zhou-li-kou-da-qia.html</guid><pubDate>Mon, 02 Dec 2024 05:23:45 +0000</pubDate></item><item><title>VSCode CMake配置</title><link>https://XLXXLXXLX.github.io/post/VSCode%20CMake-pei-zhi.html</link><description>&gt;在一千次重新学习如何配置后，决定做个记录&#13;
&#13;
# 使用${workspaceFolder}/.vscode/settings.json&#13;
以构建cling时使用的配置为例：&#13;
```js&#13;
{&#13;
    'cmake.sourceDirectory': '${workspaceFolder}/llvm-project/llvm/', // 会作为 -S 参数传递给命令行&#13;
    'cmake.buildDirectory': '${workspaceFolder}/cling-build',         // 会作为 -B 参数传递给命令行&#13;
    'cmake.configureSettings': {&#13;
        // 以 -D${key}=${value} 方式传递给命令行&#13;
        'LLVM_TARGETS_TO_BUILD': 'host;NVPTX', &#13;
        'LLVM_ENABLE_PROJECTS': 'clang',&#13;
        'LLVM_EXTERNAL_PROJECTS': 'cling',&#13;
        'LLVM_EXTERNAL_CLING_SOURCE_DIR': '${workspaceFolder}/cling/',&#13;
        'CMAKE_EXPORT_COMPILE_COMMANDS': 'ON'&#13;
    },&#13;
    'cmake.configureArgs': [&#13;
        // 也可以直接这里传入&#13;
        '-DCMAKE_BUILD_TYPE=Release',&#13;
    ],&#13;
    'cmake.buildArgs': [&#13;
        // --build 时会传入&#13;
        '--parallel',&#13;
    ],&#13;
    'clangd.arguments': [&#13;
        // compile_commands.json path:&#13;
        '--compile-commands-dir=${workspaceFolder}/cling-build',&#13;
    ],&#13;
}&#13;
```&#13;
&#13;
# 使用${workspaceFolder}/cmakePresets.json&#13;
``#TODO``。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/VSCode%20CMake-pei-zhi.html</guid><pubDate>Thu, 28 Nov 2024 10:23:40 +0000</pubDate></item><item><title>12月计划</title><link>https://XLXXLXXLX.github.io/post/12-yue-ji-hua.html</link><description>### 毕设&#13;
- [ ] 看完龙书&#13;
- [ ] 学llvm，写一些demo&#13;
- [ ] 读cling源码，读一些博客&#13;
- [ ] 应付老师&#13;
&#13;
### 课程&#13;
- [ ] 把表达与交流的考勤补一下&#13;
- [ ] 把欠的作业补一下&#13;
&#13;
### 自学&#13;
- [ ] 把Java语法全部过完，搞个SpringBoot项目（开个头就行）&#13;
&#13;
### 读书&#13;
- [ ] 把《劳工的力量》看完&#13;
- [ ] 然后再选一本去读一下&#13;
&#13;
### 其他&#13;
- [x] 把三方的手续搞完&#13;
- [ ] 等华子开奖，看看能给多少&#13;
&#13;
。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/12-yue-ji-hua.html</guid><pubDate>Thu, 28 Nov 2024 05:57:13 +0000</pubDate></item><item><title>Shell 脚本</title><link>https://XLXXLXXLX.github.io/post/Shell%20-jiao-ben.html</link><description>为了克服使用shell脚本“每次用到每次还要再查”的现状，尝试做一些记录，虽然还是参考[菜鸟教程](https://www.runoob.com/linux/linux-shell-process-control.html)（）&#13;
&#13;
### 流程控制&#13;
&#13;
下文中的condition是`[ ... ]`或者`(( ... ))`的格式，前者需要使用`-lt`等比较方法，而后者可以使用`&gt;`、`&lt;`等比较符&#13;
&#13;
- if语句：&#13;
&#13;
```shell&#13;
if condition&#13;
then&#13;
    command1 &#13;
    command2&#13;
    commandN &#13;
fi&#13;
#或者&#13;
if condition; then; command1; command2; fi&#13;
```&#13;
&#13;
- for循环：&#13;
&#13;
```sh&#13;
for var in item1 item2 ... itemN&#13;
do&#13;
    command1&#13;
    command2&#13;
    ...&#13;
    commandN&#13;
done&#13;
&#13;
#或者&#13;
for var in item1 item2 ... itemN; do command1; command2… done;&#13;
```&#13;
&#13;
- while语句：&#13;
&#13;
```sh&#13;
while condition&#13;
do&#13;
    command&#13;
done&#13;
#或者&#13;
while condition; do command; done;&#13;
```&#13;
&#13;
- case ... esac 多选择语句&#13;
&#13;
```sh&#13;
case 值 in&#13;
模式1)&#13;
    command1&#13;
    command2&#13;
    ...&#13;
    commandN&#13;
    ;;&#13;
模式2)&#13;
    command1&#13;
    command2&#13;
    ...&#13;
    commandN&#13;
    ;;&#13;
esac&#13;
#例如&#13;
echo '输入 1 到 4 之间的数字:'&#13;
echo '你输入的数字为:'&#13;
read aNum&#13;
case $aNum in&#13;
    1)  echo '你选择了 1'&#13;
    ;;&#13;
    2)  echo '你选择了 2'&#13;
    ;;&#13;
    3)  echo '你选择了 3'&#13;
    ;;&#13;
    4)  echo '你选择了 4'&#13;
    ;;&#13;
    *)  echo '你没有输入 1 到 4 之间的数字'&#13;
    ;;&#13;
esac&#13;
```&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
### Shell函数&#13;
&#13;
下面是shell函数的一般格式（\[ \]内部的可以省略）&#13;
&#13;
```sh&#13;
# 函数定义&#13;
[ function ] funname [()]&#13;
{&#13;
    action;&#13;
    [return int;]&#13;
}&#13;
# 函数调用&#13;
funnname&#13;
```&#13;
&#13;
&#13;
&#13;
| 参数处理 | 说明                              |&#13;
| ---- | ------------------------------- |&#13;
| $#   | 传递到脚本或函数的参数个数                   |&#13;
| $*   | 以一个单字符串显示所有向脚本传递的参数             |&#13;
| $$   | 脚本运行的当前进程ID号                    |&#13;
| $!   | 后台运行的最后一个进程的ID号                 |&#13;
| $@   | 与$*相同，但是使用时加引号，并在引号中返回每个参数。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/Shell%20-jiao-ben.html</guid><pubDate>Tue, 26 Nov 2024 12:29:04 +0000</pubDate></item><item><title>Linux 实用命令记录</title><link>https://XLXXLXXLX.github.io/post/Linux%20-shi-yong-ming-ling-ji-lu.html</link><description>&#13;
```sh&#13;
nohup ${some_command} &gt; outlog.txt 2&gt;&amp;1 &amp;&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/Linux%20-shi-yong-ming-ling-ji-lu.html</guid><pubDate>Tue, 26 Nov 2024 08:58:13 +0000</pubDate></item><item><title>Java面向对象（与C++对比）</title><link>https://XLXXLXXLX.github.io/post/Java-mian-xiang-dui-xiang-%EF%BC%88-yu-C%2B%2B-dui-bi-%EF%BC%89.html</link><description>&#13;
```java&#13;
class Person {&#13;
    // 每个成员变量/方法（包括构造方法）都需要指明控制访问权限&#13;
    private String name = 'Unamed'; // 和C++一样，&#13;
                                    // 可以在定义时对成员变量规定初始化&#13;
                                    // 同样也会被构造方法覆盖掉&#13;
    // final 变量不可更改，类似于const&#13;
    // static表示该字段/方法是静态的（属于类而不是对象），与C++类似&#13;
    public static final String SPECIES = 'Homo sapien'; &#13;
    private static int POPULATION = 0;&#13;
&#13;
    private int age = 18; &#13;
&#13;
    protected String[] nicknames;// 如果没有在构造方法中初始化字段，&#13;
                               // 引用类型默认是null，基本类型用默认值&#13;
&#13;
    public Person() {&#13;
        this('Whoever', 18); // 可以使用类似C++委托构造的语法&#13;
    }&#13;
&#13;
    public Person(String name, int age) {&#13;
        // 和C++一样，如果我们定义了构造方法&#13;
        // 那么编译器就不会再生成默认构造方法&#13;
        POPULATION++;&#13;
        this.name = name;&#13;
        this.age = age;&#13;
        this.nicknames = new String[];&#13;
    }&#13;
&#13;
    public String getName() {&#13;
        return this.name;&#13;
    }&#13;
&#13;
    // 对于引用参数，传参是引用的&#13;
    public void setName(String name) { &#13;
        this.name = name; // this是“引用”，而不是指针，不需要'-&gt;'语法 &#13;
                          // 赋值却是拷贝的，对于String,默认就是深拷贝        &#13;
    }&#13;
&#13;
    public int getAge() {&#13;
        return this.age;&#13;
    }&#13;
&#13;
    // 对于基本类型（如int），传参是拷贝&#13;
    public void setAge(int age) { // 没有“默认参数”的语法&#13;
        if (age &lt; 0 || age &gt; 100) {&#13;
            throw new IllegalArgumentException('invalid age value');&#13;
        }&#13;
        this.age = age;&#13;
    }&#13;
&#13;
    public void setNicknames(String... nicknames) { &#13;
        // 可变参数的声明和使用比C++简单得多&#13;
        // 实际上几乎就是一个数组，只不过能够接受null值&#13;
        // 且不需要手动来(new T[])构造参数，直接(T t1, T t2, ...)就好&#13;
        this.nicknames = nicknames;&#13;
    }&#13;
&#13;
    public static class PopulationManagement{ // Java支持嵌套类&#13;
        public static void addPopulation(int n){&#13;
            Person.POPULATION += n; // 嵌套类拥有访问private的权限&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    public void say(){&#13;
        System.out.println('Hi!\n');&#13;
    }&#13;
&#13;
    public void say(String sth){ // 支持重载&#13;
        System.out.println(sth);&#13;
    }&#13;
&#13;
    public final void sayAge(){ // final 方法不能覆写&#13;
        System.out.println(age);&#13;
    }&#13;
&#13;
    @Override&#13;
    public String toString(){ // 覆写Object的方法&#13;
                              // 还可以覆写equals、hashCode等方法&#13;
        String res = 'name: ' + name + ', age: ' + age; // 局部变量&#13;
        return res;&#13;
    }&#13;
}&#13;
```&#13;
&#13;
```java&#13;
class Student extends Person { // 继承用extends关键字，Java只支持单继承&#13;
                               // 所有的class最终都继承自Object&#13;
    // 子类无法访问父类的private字段/方法&#13;
    // 但可以访问父类（以及祖先类）protected字段/方法&#13;
    private int score;&#13;
&#13;
    public Student(String name, int age, int score){&#13;
        super(name, age); // 不同于C++，Java子类的构造方法必须手动被调用&#13;
                          // 子类不会继承任何父类的构造方法&#13;
        this.score = score;    &#13;
    }&#13;
&#13;
    @Override // 不是必需的，但可以帮助编译器检查&#13;
    public say(){&#13;
        System.out.println(getName()); // 基类private变量不可访问&#13;
        for(String nickname : super.nicknames){ // 基类protected变量可访问&#13;
            System.out.println(nickname);&#13;
        }&#13;
    }&#13;
    public int getScore(){...}&#13;
    public void setScore(int score){...}&#13;
}                             &#13;
```&#13;
&#13;
```java&#13;
Person.SPECIES == 'Homo sapien'&#13;
Person.PopulationManageerson.PopulationManage&#13;
P&#13;
Person p1 = new Person(); &#13;
Person p2 = new Student(); // 基类引用可以指向派生类，称为向下转型&#13;
Student s1 = (Student) p1; // runtime error! ClassCastException!&#13;
Student s2 = (Student) p2; // ok&#13;
p2.say(); // 基于运行时多态，会调用Student的say方法 &#13;
// instanceof 操作符&#13;
p1 instance of Person == true&#13;
p1 instance of Student == false&#13;
p2 instance of Person == true&#13;
p2 instance of Student == true&#13;
// Java 14 以后&#13;
        Object obj = 'hello';&#13;
    f (obj instanceof String s) {&#13;
    // 可以直接使用变量s:&#13;
    System.out.println(s.toUpperCase());&#13;
}&#13;
```&#13;
&#13;
```java&#13;
public sealed class Shape permits Rect, Circle, Triangle {&#13;
    // 用sealed关键字修饰后，该类只允许permits后面Rect, Circle, Triangle三个类继承&#13;
    // Java17后支持，C++似乎没有类似的语法？&#13;
    public abstract double area(); // 类似于 C++ virtual f()  = 0;&#13;
                                   // 同样，含有抽象方法的类是抽象类，不能实例化&#13;
}&#13;
&#13;
public final class Rect extends Shape {...} // final修饰的类不允许再被继承&#13;
```&#13;
&#13;
```java&#13;
package world.of.transformers // 包类似于namespace，但和Python的包概念更像&#13;
                      // 包之间没有父子关系，包要和项目中的目录结构对应&#13;
                      // 比如，这个包可以访问所有包名为world.of.transformers的文件的内容&#13;
                      // 推荐的做法是使用倒置的域名来确保唯一性，eg. org.apache&#13;
&#13;
/*&#13;
package_sample&#13;
└─ src&#13;
   └─ world&#13;
      └─ of&#13;
         └─transformers&#13;
            └─Verhicle.java&#13;
*/&#13;
&#13;
interface Verhicle { // 接口相当于没有非静态字段的抽象类&#13;
    void run();&#13;
}&#13;
&#13;
interface Car extends Verhicle{ // 接口也可以继承&#13;
    default void getFueled(){ // 实现类如果不覆写default方法则使用默认的&#13;
        System.out.println('fueling\n');&#13;
    }&#13;
    void startEngine(){&#13;
        Runnable r = new Runnable() { // 匿名类，实现Runnable接口&#13;
            @Override&#13;
            public void run(){&#13;
                while(true){&#13;
                    Thread.sleep(10000);&#13;
                    System.out.println('Engine running\n');&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
interface Bicycle extends Verhicle{&#13;
    public static wheelNum = 2; // 接口只可以有静态字段&#13;
}&#13;
&#13;
public /*这个public表示其他包可以访问他*/ class Transformer implements Verhicle { &#13;
                                                    // 类要实现接口，&#13;
                                                    // 不是用extends，而是用implements&#13;
    void run() {&#13;
        System.out.println('Transformer running\n');&#13;
    }&#13;
}&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/Java-mian-xiang-dui-xiang-%EF%BC%88-yu-C%2B%2B-dui-bi-%EF%BC%89.html</guid><pubDate>Tue, 26 Nov 2024 06:19:51 +0000</pubDate></item><item><title>CMake笔记</title><link>https://XLXXLXXLX.github.io/post/CMake-bi-ji.html</link><description>&#13;
生成 compile_commands.json&#13;
```&#13;
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/CMake-bi-ji.html</guid><pubDate>Mon, 25 Nov 2024 08:40:00 +0000</pubDate></item><item><title>使用tlp来为我的Debian省电</title><link>https://XLXXLXXLX.github.io/post/shi-yong-tlp-lai-wei-wo-de-Debian-sheng-dian.html</link><description>```sh&#13;
sudo apt install tlp tlp-rdw&#13;
sudo systemctl enable --now tlp&#13;
suod vim /etc/tlp.conf&#13;
```&#13;
```&#13;
# in /etc/tlp.conf&#13;
CPU_SCALING_GOVERNOR_ON_AC=performance&#13;
CPU_SCALING_GOVERNOR_ON_BAT=powersave&#13;
DISK_APM_LEVEL_ON_AC='254'&#13;
DISK_APM_LEVEL_ON_BAT='128'&#13;
```&#13;
&#13;
参考资料：&#13;
1. [使用 tlp 来为 linux 省电](https://www.meow-2.com/posts/linux/tlp-for-power-saving)&#13;
2. [TLP：一个可以延长 Linux 笔记本电池寿命的高级电源管理工具](https://linux.cn/article-10848-1.html)。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/shi-yong-tlp-lai-wei-wo-de-Debian-sheng-dian.html</guid><pubDate>Mon, 25 Nov 2024 02:21:43 +0000</pubDate></item><item><title>Docker常见用法汇总记录</title><link>https://XLXXLXXLX.github.io/post/Docker-chang-jian-yong-fa-hui-zong-ji-lu.html</link><description>### Docker进入容器：&#13;
```sh&#13;
docker exec -it ${容器ID} /bin/bash&#13;
```&#13;
### 为`docker pull`添加代理&#13;
在执行docker pull时，是由守护进程dockerd来执行。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/Docker-chang-jian-yong-fa-hui-zong-ji-lu.html</guid><pubDate>Sun, 24 Nov 2024 09:09:28 +0000</pubDate></item><item><title>Debian 12 使用apt安装Java8或Java11</title><link>https://XLXXLXXLX.github.io/post/Debian%2012%20-shi-yong-apt-an-zhuang-Java8-huo-Java11.html</link><description>```sh&#13;
# using root&#13;
&#13;
mkdir -p /etc/apt/keyrings&#13;
&#13;
wget -O - https://packages.adoptium.net/artifactory/api/gpg/key/public | tee /etc/apt/keyrings/adoptium.asc&#13;
&#13;
echo 'deb [signed-by=/etc/apt/keyrings/adoptium.asc] https://packages.adoptium.net/artifactory/deb $(awk -F= '/^VERSION_CODENAME/{print$2}' /etc/os-release) main' | tee /etc/apt/sources.list.d/adoptium.list&#13;
&#13;
apt update &#13;
&#13;
apt install temurin-8-jdk&#13;
&#13;
update-alternatives --config java # choose new java&#13;
update-alternatives --config javac # choose new javac&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/Debian%2012%20-shi-yong-apt-an-zhuang-Java8-huo-Java11.html</guid><pubDate>Fri, 22 Nov 2024 08:10:00 +0000</pubDate></item><item><title>SpringBoot入门笔记</title><link>https://XLXXLXXLX.github.io/post/SpringBoot-ru-men-bi-ji.html</link><description># SpringBoot初始化&#13;
&#13;
打开IDEA，新建Maven模块，设置组名和工件名：&#13;
![2024-11-22_15-33](https://github.com/user-attachments/assets/27683b25-05eb-4706-8c8c-0ac32906454d)&#13;
&#13;
在pom.xml中添加springboot相关依赖（下面的示例来自[Spring Boot Reference Guide](https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/getting-started-installing-spring-boot.html#getting-started-maven-installation)）：&#13;
```xml&#13;
&lt;?xml version='1.0' encoding='UTF-8'?&gt;&#13;
&lt;project xmlns='http://maven.apache.org/POM/4.0.0' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'&#13;
	xsi:schemaLocation='http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd'&gt;&#13;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&#13;
&#13;
	&lt;groupId&gt;com.example&lt;/groupId&gt;&#13;
	&lt;artifactId&gt;myproject&lt;/artifactId&gt;&#13;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&#13;
&#13;
	&lt;!-- Inherit defaults from Spring Boot --&gt;&#13;
	&lt;parent&gt;&#13;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#13;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&#13;
		&lt;version&gt;2.1.6.RELEASE&lt;/version&gt;&#13;
	&lt;/parent&gt;&#13;
&#13;
	&lt;!-- Add typical dependencies for a web application --&gt;&#13;
	&lt;dependencies&gt;&#13;
		&lt;dependency&gt;&#13;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#13;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&#13;
		&lt;/dependency&gt;&#13;
	&lt;/dependencies&gt;&#13;
&#13;
	&lt;!-- Package as an executable jar --&gt;&#13;
	&lt;build&gt;&#13;
		&lt;plugins&gt;&#13;
			&lt;plugin&gt;&#13;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&#13;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&#13;
			&lt;/plugin&gt;&#13;
		&lt;/plugins&gt;&#13;
	&lt;/build&gt;&#13;
&#13;
&lt;/project&gt;&#13;
```&#13;
&#13;
&#13;
# 最小应用&#13;
注解`@SpringBootApplication`是SpringBoot项目的入口：&#13;
_HelloApplication.java_&#13;
```java&#13;
@SpringBootApplication&#13;
public class HelloApplication {&#13;
    public static void main(String[] args) {&#13;
        SpringApplication.run(HelloApplication.class);&#13;
    }&#13;
}&#13;
```&#13;
使用`@RestController`和`@RequestMapping`进行路由：&#13;
_HelloController.java_&#13;
```java&#13;
@RestController&#13;
public class HelloController {&#13;
    @RequestMapping('/hello')&#13;
    public String hello() {&#13;
        return 'Hello, SpringBoot!\n';&#13;
    }&#13;
}&#13;
```&#13;
&#13;
# 读取YAML配置文件&#13;
三种方法：&#13;
1. `@Value`&#13;
2. `@Autowired` + `Environment`&#13;
3. `@Autowired` + `@ConfigurationProperties`&#13;
&#13;
_my `application.yml` config example:_&#13;
```yaml&#13;
spring:&#13;
  profiles:&#13;
    active:&#13;
      dev # -&gt; application-dev.yml&#13;
      # pro -&gt; application-pro.yml&#13;
      # one-file-dev -&gt; 下面---里面的配置&#13;
---&#13;
spring:&#13;
  profiles: one-file-dev&#13;
server:&#13;
  port: 8083&#13;
name1: 'chito'&#13;
student: { name: 'xlx',gender: 'male',age: 22 }&#13;
sentence1: 'test \n test'&#13;
sentence2: 'test \n test' # 双引号才识别转义&#13;
array1:&#13;
  - 0&#13;
  - 1&#13;
  - 2&#13;
array2: [ 1,2,3,4,5 ]&#13;
---&#13;
```&#13;
_SpringBoot读取`application.yml`：_&#13;
_ReadFromYAMLController.java_&#13;
```java&#13;
&#13;
@RestController&#13;
public class ReadFromYAMLController {&#13;
    @Value('${name1}')      // 这个名字和yml中的字段名一致&#13;
    private String name_1;  // 这个名字不需要一致&#13;
&#13;
    @Autowired&#13;
    private Environment env; // 导入yml中的所有内容&#13;
    @Autowired&#13;
    private Student stu;&#13;
&#13;
    @RequestMapping('/hello')&#13;
    public String hello() {&#13;
        String res = '\nname1: ' + name_1;&#13;
        res += '\nsentence1: ' + sentence1;&#13;
        res += '\nsentence2: ' + sentence2;&#13;
        return 'Hello, SpringBoot!\n' + res;&#13;
    }&#13;
&#13;
    @RequestMapping('/env')&#13;
    public String env() {&#13;
        String sentence = env.getProperty('sentence1');&#13;
        return sentence;&#13;
    }&#13;
&#13;
    @RequestMapping('stu')&#13;
    public String stu(){&#13;
        return stu.toString();&#13;
    }&#13;
}&#13;
```&#13;
_Student.java：_&#13;
```java&#13;
@Component  // 表明这是一个Java Bean&#13;
@ConfigurationProperties(prefix = 'student')  // 将application.yml中的student及其成员注入进来&#13;
public class Student {&#13;
    private String name;&#13;
    private String gender;&#13;
    private int age;&#13;
&#13;
    /*&#13;
     * 省略Getter、Setter、toString&#13;
     */&#13;
}&#13;
&#13;
```&#13;
。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/SpringBoot-ru-men-bi-ji.html</guid><pubDate>Fri, 22 Nov 2024 08:08:26 +0000</pubDate></item><item><title>11/25/2024</title><link>https://XLXXLXXLX.github.io/post/11-25-2024.html</link><description>1. （因为觉得不需要）把swap分区删了，结果导致开机会卡住一段时间，从boot日志上发现`gave up waiting for suspend/resume device`，顾名思义，估计是linux的快速恢复机制会把系统写到swap里去，所以干脆就不要快速恢复了：&#13;
```sh&#13;
su -&#13;
rm /etc/initramfs-tools/conf.d/resume&#13;
update-initramfs -u&#13;
exit&#13;
```&#13;
&#13;
2. 装OnlyOffice Desktop时发现有一个叫`ttf-mscorefonts-installer`的依赖死活装不上。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/11-25-2024.html</guid><pubDate>Fri, 22 Nov 2024 06:39:51 +0000</pubDate></item><item><title>maven 设置代理</title><link>https://XLXXLXXLX.github.io/post/maven%20-she-zhi-dai-li.html</link><description>在`~/m2/settings.xml`中：&#13;
```xml&#13;
&lt;settings&gt;&#13;
 &lt;proxies&gt;&#13;
     &lt;proxy&gt; &#13;
       &lt;id&gt;workProxy&lt;/id&gt; &#13;
       &lt;active&gt;true&lt;/active&gt; &#13;
       &lt;protocol&gt;http&lt;/protocol&gt;&#13;
       &lt;!--   &lt;username&gt;admin&lt;/username&gt;       --&gt;&#13;
       &lt;!--   &lt;password&gt; admin&lt;/password&gt;        --&gt;&#13;
       &lt;host&gt;127.0.0.1&lt;/host&gt;&#13;
       &lt;port&gt;10809&lt;/port&gt;   &#13;
       &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;    &#13;
     &lt;/proxy&gt;&#13;
 &lt;/proxies&gt;&#13;
&lt;/settings&gt;&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/maven%20-she-zhi-dai-li.html</guid><pubDate>Thu, 21 Nov 2024 14:11:08 +0000</pubDate></item><item><title>npm 换源、代理设置</title><link>https://XLXXLXXLX.github.io/post/npm%20-huan-yuan-%E3%80%81-dai-li-she-zhi.html</link><description>换源：&#13;
```sh&#13;
npm config set registry=https://registry.npmmirror.com&#13;
```&#13;
&#13;
代理&#13;
```&#13;
npm config set proxy http://&lt;username&gt;:&lt;password&gt;@&lt;proxy-server-url&gt;:&lt;port&gt;&#13;
npm config set https-proxy http://&lt;username&gt;:&lt;password&gt;@&lt;proxy-server-url&gt;:&lt;port&gt;&#13;
```&#13;
&#13;
。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/npm%20-huan-yuan-%E3%80%81-dai-li-she-zhi.html</guid><pubDate>Thu, 21 Nov 2024 11:14:04 +0000</pubDate></item><item><title>正则表达式记录</title><link>https://XLXXLXXLX.github.io/post/zheng-ze-biao-da-shi-ji-lu.html</link><description>`网页名 url`转markdown格式：&#13;
```regex&#13;
^(.*) (http.*)$&#13;
```&#13;
&#13;
Vivaldi 书签导出格式正则表达式提取url + 网页名：&#13;
```regex&#13;
^&lt;DT&gt;&lt;A HREF='(http.*)' ADD_DATE.*&gt;(.*)&lt;/A&gt;$&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/zheng-ze-biao-da-shi-ji-lu.html</guid><pubDate>Mon, 18 Nov 2024 12:05:47 +0000</pubDate></item><item><title>rsync 配置</title><link>https://XLXXLXXLX.github.io/post/rsync%20-pei-zhi.html</link><description>客户端，在不同文件系统中使用rsync时，可能出现文件系统时间格式不兼容，由于我也不在意文件时间的同步，于是加上了`--no-times`参数，端口默认值为873，可以自定义：&#13;
```sh&#13;
rsync -avzsPuriy --no-times --delete 'rsync://username@ip:port/path/to/folder' /localpath/to/folder&#13;
```&#13;
服务端：&#13;
```&#13;
sudo apt install rsync&#13;
sudo systemctl enable --now rsync&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/rsync%20-pei-zhi.html</guid><pubDate>Mon, 18 Nov 2024 11:03:20 +0000</pubDate></item><item><title>ssh 配置</title><link>https://XLXXLXXLX.github.io/post/ssh%20-pei-zhi.html</link><description>生成ssh密钥对：&#13;
```sh&#13;
ssh-keygen -t rsa -b 4096 -C 'miasanmia147@gmail.com'&#13;
```&#13;
ssh使用代理：&#13;
```&#13;
ssh ${target}  -T -c aes128-gcm@openssh.com -o ProxyCommand='nc -X 5 -x ${ip}:${port} %h %p' -o Compression=no -x'&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/ssh%20-pei-zhi.html</guid><pubDate>Mon, 18 Nov 2024 10:53:46 +0000</pubDate></item><item><title>Samba网络文件系统的简单配置</title><link>https://XLXXLXXLX.github.io/post/Samba-wang-luo-wen-jian-xi-tong-de-jian-dan-pei-zhi.html</link><description>下文中的`${xxx}`仅仅代表此处为自定义，`[xxx]`表示此处为可选值，并非需要使用这些格式。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/Samba-wang-luo-wen-jian-xi-tong-de-jian-dan-pei-zhi.html</guid><pubDate>Tue, 12 Nov 2024 10:45:34 +0000</pubDate></item><item><title>11/9/2024</title><link>https://XLXXLXXLX.github.io/post/11-9-2024.html</link><description>好，从今天开始，秋招真的结束了。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/11-9-2024.html</guid><pubDate>Sat, 09 Nov 2024 14:22:03 +0000</pubDate></item><item><title>zsh 配置</title><link>https://XLXXLXXLX.github.io/post/zsh%20-pei-zhi.html</link><description>```sh&#13;
sudo apt install zsh&#13;
chsh -s /usr/bin/zsh&#13;
sh -c '$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)'&#13;
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting&#13;
git clone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:-${ZSH:-~/.oh-my-zsh}/custom}/plugins/zsh-completions&#13;
git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions&#13;
```&#13;
&#13;
&#13;
```sh&#13;
source ~/.scripts/enabled/*&#13;
&#13;
ulimit -c unlimited&#13;
&#13;
&#13;
export ZSH='$HOME/.oh-my-zsh'&#13;
&#13;
ZSH_THEME='af-magic'&#13;
&#13;
plugins=(git&#13;
        zsh-completions&#13;
        zsh-autosuggestions&#13;
        zsh-syntax-highlighting&#13;
        z&#13;
        sudo&#13;
        rsync&#13;
        python&#13;
        golang&#13;
        )&#13;
&#13;
source $ZSH/oh-my-zsh.sh&#13;
&#13;
# Compilation flags&#13;
# export ARCHFLAGS='-arch x86_64'&#13;
alias zshconfig='vim ~/.zshrc'&#13;
alias omzconfig='vim ~/.oh-my-zsh'&#13;
&#13;
eval '$(register-python-argcomplete pipx)'&#13;
&#13;
&#13;
[[ -s '/home/chito/.gvm/scripts/gvm' ]] &amp;&amp; source '/home/chito/.gvm/scripts/gvm'&#13;
&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/zsh%20-pei-zhi.html</guid><pubDate>Fri, 08 Nov 2024 08:55:26 +0000</pubDate></item><item><title>MySQL系统管理命令汇总</title><link>https://XLXXLXXLX.github.io/post/MySQL-xi-tong-guan-li-ming-ling-hui-zong.html</link><description>- 创建数据库，设定数据库字符集为utf8mb4&#13;
```&#13;
CREATE DATABASE db_name DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;&#13;
CREATE DATABASE db_name DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;&#13;
```&#13;
- 设定数据库字符集为gbk，名称为mydb2&#13;
```&#13;
CREATE DATABASE db_name DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;&#13;
```&#13;
- 更改数据库的字符编码&#13;
```&#13;
ALTER DATABASE db_name DEFAULT CHARACTER SET gbk  COLLATE gbk_chinese_ci;&#13;
```&#13;
- 数据库的简单备份与还原&#13;
```&#13;
mysqldump -h [hostname] -P [port] -u [username] -p --database [database_name] &gt; filename.sql&#13;
mysqldump -h [hostname] -P [port] -u [username] -p --database [database_name] &lt; filename.sql&#13;
```。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/MySQL-xi-tong-guan-li-ming-ling-hui-zong.html</guid><pubDate>Tue, 05 Nov 2024 15:55:00 +0000</pubDate></item><item><title>【转载】大教堂与集市 by Eric Steven Raymond</title><link>https://XLXXLXXLX.github.io/post/%E3%80%90-zhuan-zai-%E3%80%91-da-jiao-tang-yu-ji-shi-%20by%20Eric%20Steven%20Raymond.html</link><description># 第一章 教堂与市集&#13;
&#13;
&#13;
Linux 打破了许多软件开发的传统，这个世界级的操作系统在五年前（1991 年）仅仅靠着如丝般的互联网，神奇地联合了散布在全世界数以千计兼职的玩家们来开发它，谁曾料到会发生这样的事情呢？&#13;
&#13;
我当然也没料到，Linux 出现在我电脑屏幕是在 1993 年初，当时我埋首于 UNIX 及开源的软件开发已有十年，1980 年代中期，我是 GNU [^1] 项目首批的贡献者之一，我写过许多开源的软件放到网络上供人使用，也曾独立或协同开发好几个程序（nethack，Emacs 的 VC 和 GUD 功能，xlife，...等等），这些程序到今天仍广泛地为人所用，我想我知道这是怎么办到的。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/%E3%80%90-zhuan-zai-%E3%80%91-da-jiao-tang-yu-ji-shi-%20by%20Eric%20Steven%20Raymond.html</guid><pubDate>Mon, 04 Nov 2024 13:52:15 +0000</pubDate></item><item><title>Git常见场景用法汇总</title><link>https://XLXXLXXLX.github.io/post/Git-chang-jian-chang-jing-yong-fa-hui-zong.html</link><description>对于我个人而言，大概有下面几类git命令：&#13;
&#13;
1. 常用的、不需要记忆的、熟练的git命令&#13;
2. 有用的、需要记忆的、不熟练的git命令&#13;
3. 可以被图形化界面替代的、偶尔用到的git命令&#13;
4. 其他命令&#13;
&#13;
下面主要记录后三种：&#13;
&#13;
### 本地查看&#13;
- GitHub 有一个十分详细的针对数十种项目及语言的[`.gitignore`文件列表](https://github.com/github/gitignore)&#13;
- 查看所有未暂存的改动：&#13;
```&#13;
git diff&#13;
```&#13;
- 查看所有已暂存的改动：&#13;
```&#13;
git diff --staged&#13;
```&#13;
- 更好的git log，可以alias到glg：&#13;
```&#13;
git log --all --graph --decorate --oneline&#13;
```&#13;
&#13;
### 本地编辑&#13;
- 把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/Git-chang-jian-chang-jing-yong-fa-hui-zong.html</guid><pubDate>Sun, 03 Nov 2024 16:01:48 +0000</pubDate></item><item><title>10/26/2024</title><link>https://XLXXLXXLX.github.io/post/10-26-2024.html</link><description>感觉前端这些东西是真的混乱啊，很多都是强行加戏。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/10-26-2024.html</guid><pubDate>Sat, 26 Oct 2024 09:58:47 +0000</pubDate></item><item><title>10/25/2024</title><link>https://XLXXLXXLX.github.io/post/10-25-2024.html</link><description>从今天开始，秋招结束了，学一些真正想学的东西，做一些真正想做的事。</description><guid isPermaLink="true">https://XLXXLXXLX.github.io/post/10-25-2024.html</guid><pubDate>Thu, 24 Oct 2024 16:02:12 +0000</pubDate></item></channel></rss>