# 周一 
n皇后II https://leetcode.cn/problems/n-queens-ii/
好久不写了，脑袋木掉了。
总之就是回溯+状态压缩（位运算），用三个比特集合存储横行、左斜行、右斜行的情况，然后按列扫描并回溯就好。
用到了[std::bitset](https://zh.cppreference.com/w/cpp/utility/bitset)，这个感觉还算有点用。
```cpp
class Solution {
public:
    std::bitset<10>col{0};
    std::bitset<20>diag1{0}, diag2{0};
    int cnt{0};
    void queen(int row, int n){
        if(row == n){
        // std::cout<<"row = "<<row<<'\n';
        // std::cout<<col.to_string()<<'\n';
        // std::cout<<diag1.to_string()<<'\n';
        // std::cout<<diag2.to_string()<<'\n';
            cnt++;
            return;
        }
        for(int i = 0; i < n; i++){
        // 左斜行和右斜行的idx搞对就好
            if(!col[i] && !diag1[i + row] && !diag2[i + n - 1 - row]){
                col[i] = 1;
                diag1[i + row] = 1;
                diag2[i + n - 1 - row] = 1;
                queen(row + 1, n);
                col[i] = 0;
                diag1[i + row] = 0;
                diag2[i + n - 1 - row] = 0;
            }
        }
    }
    int totalNQueens(int n) {
        queen(0, n);
        return cnt;
    }
};
```